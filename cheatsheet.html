<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.0.min.js"></script>
    <title>Title</title>

---------------------------------------------------------------------------------

---------------------------------------------------------------------------------
    document ready
    <script>
        (function ($, undefined) {
            ///
        })(jQuery);
    </script>
    $() — это синоним для jQuery().

---------------------------------------------------------------------------------
примеры селекторов    https://antonshevchuk.gitbooks.io/jquery-for-beginners/content/10_go_on/selectors.html
---------------------------------------------------------------------------------
список событий     https://developer.mozilla.org/ru/docs/Web/Events
---------------------------------------------------------------------------------

    остановить "всплытие" событий
<script>
    $("a").click(function(event) {
        alert("Hello!");
        event.preventDefault();
        event.stopPropagation();
    })
</script>

                  или

<script>
    $("a").click(function(event) {
        return false;
    })
</script>

 не понял в чем тут разница ↓

    <script>
        $("a").click(function(event) {        // ваш обработчик события
            alert("Hello!");                  // он избранный
            event.stopImmediatePropagation(); // он должен остаться только один
            return false;
        })
    </script>
    и
    <script>
        $("a").click(function(event) { // а это чужой обработчик событий
            alert("Hello again!");     // он делает всё неправильно
            return false;
        })
    </script>
------------------------------------------------------------------------------------------------
    // удаляем все обработчики
    $("p").off();

    // удаляем все обработчики click
    $("p").off("click");

    // вызываем все обработчики события click
    $("p").trigger("click");

    //вызываем обработчик событий привязаный к namespace
    $("p").trigger("click.namespace");

    // вызываем все обработчики без пространства имён
    $("p").trigger("click.$");

    // удаляем все обработчики click в данном пространстве имён
    $("p").off("click.namespace");
----------------------------------------------------------------------------------------------
АНИМАЦИЯ

    // скроем все картинки
    <script>
        $('img').hide();
    </script>

    // теперь вернём их на место
    <script>
        $('img').show();
    </script>

    2 предыдущих в одном (переключатель)
    <script>
        $('img').toggle();
    </script>

    скрыть в левый верхний угол
    <script>
        $('img').hide(600);  //←(время в мс)
    </script>

    показать с того же угла
    <script>
        $('img').show(600);
    </script>


    // добавить колбэк функцию, будет выполнена по окончанию анимации
    //slow или fast стандартные значения скорости (600 и 200)
    <script>
        $('img').hide('slow', function(){
            // опосля отображаем alert
            alert("Images was hidden");
        });
    </script>


    ну тут и так понятно что оно делает
    <script>
        $('img').slideUp();
    </script>

    <script>
        $('img').slideDown();
    </script>

    <script>
        $('img').slideToggle();
    </script>


    изменяет «opacity» от 0 до предыдущего значения
    <script>
        $('img').fadeIn();
    </script>


    изменяет «opacity» от текущего до 0
    <script>
        $('img').fadeOut()
    </script>


    переключатель между «In» и «Out»
    <script>
        $('img').fadeToggle()
    </script>


    изменяет значение «opacity» до требуемого значения
    <script>
        $('img').fadeTo("slow", 0.5)
    </script>


    // fadeOut()
    <script>
        $('img').animate({
            'opacity': 'hide'
        })
    </script>


    // fadeIn()
    <script>
        $('img').animate({
            'opacity': 'show'
        })
    </script>


    // значения указанных свойств будут плавно изменяться
    // от текущих до заданных
    <script>
        $('img').animate({
            'opacity': 0.5,
            'height': '100px',
            'width': '100px'
        })
    </script>

    // изменяем, шаг за шагом
    <script>
        $('img').animate({
            'opacity': '+=0.1',
            'height': '+=12px',
            'width': '+=20px'
        })
    </script>

    duration – скорость анимации
    easing – функция («linear» или «swing»)
    queue – флаг/параметр очереди
    specialEasing – хэш, в котором можно описать, какую именно easing-функцию следует использовать для изменения определённых параметров
    step – функция, которая будет вызвана на каждом шаге анимации для каждого CSS-свойства; о ней расскажу чуть ниже
    complete – функция, которая будет вызвана после окончания анимации
    start – функция, которая будет вызвана до начала анимации
    progress – функция, которая будет вызвана на каждом шаге, но только единождый для элемента, вне зависимости от количества CSS-свойств
    done – функция, которая будет вызвана после успешного окончания анимации
    fail – функция, которая будет вызвана после неудачного окончания анимации
    always – функция, которая будет вызвана после окончания анимации при любом исходе





    пошаговая анимация
    <script>
        // находим нужный элемент
        $('#box')
            // указываем что хотим анимировать
            .animate({left:'-=100'})
            // следующий вызов анимации добавляется в очередь на выполнение
            .animate({top:'-=100'})
    </script>

    паралельное выполнение функций
    <script>
        // находим нужный элемент
        $('#box')
            // указываем что хотим анимировать
            .animate({left:'+=100'})
            // следующий вызов анимации будет игнорировать очередь
            .animate({top:'+=100'}, {queue:false})
    </script>

    Есть ещё функция «.stop()», которая позволяет остановить текущую анимацию на полпути, а также почистить очередь
    при необходимости. Для обеспечения различного поведения функции она принимает три параметра:
    queue — имя очереди; для работы с очередью анимации «fx» данный параметр опускаем («fx» – очередь по умолчанию)
    clearQueue — флаг очистки очереди
    jumpToEnd — применить результат анимации, али нет

    <script>
        // останавливаем выполнение текущей анимации
        $('#box').stop();
    </script>

    <script>
        // останавливаем выполнение текущей анимации
        // и всех последующих (чистим очередь)
        $('#box').stop(true);
    </script>

    <script>
        // останавливаем выполнение текущей анимации и всех последующих
        // но применяем результат текущей
        $('#box').stop(true, true);
    </script>

    <script>
        // останавливаем выполнение только текущей анимации
        // и применяем её результат
        $('#box').stop(false, true);
    </script>

    По умолчанию вся анимация над объектом складывается в очередь «fx», но с версии 1.7 можно указывать произвольную очередь:
    <script>
        $('#box')
            .animate({'top':'+=100'}, {duration: 10000, queue:'x'}) // составляем очередь X
            .dequeue('x') // запускаем очередь X

        $('#box').stop('x') // останавливаем анимацию в очереди X
    </script>

    Иногда требуется отключить всю анимацию (к примеру, для отладки) – тогда воспользуйтесь следующей конструкцией:
    <script>
        jQuery.fx.off = true;
    </script>
    ---------------------------------------------------------------------------------------------------------------------
    СОЗДАНИЕ ЭЛЕМЕНТОВ

    Лучше писать на чистом JS, так быстрее и даже удобнее
    <script>
        var myDiv = document.createElement('div');

        myDiv.id = 'my';
        myDiv.className = 'some';
    </script>

    манипуляции с элементами:    https://api.jquery.com/category/manipulation/


    добавить что-то после элемента(2 способа(одно и тоже))
    <script>
        $("нашли элемент").after("что добавляем после него?")
        $("что добавляем").insertAfter("после какого элемента?")
    </script>

    переместить элемент h1 за элемент р
    <script>
        $('p').after($('h1'))
    </script>

    before(content) — вставляет контент перед каждым выбранным элементом
    insertBefore(element) — вставляет элементы из выборки перед каждым элементом, переданным в качестве аргумента

    append(content) — вставляет контент в конец каждого элемента из выборки, т.е. строку кода
    $("p").append("<hr/>") следует читать как «в конец каждого параграфа будет добавлена линия»

    то же самое

    appendTo(element) — вставляет выбранный контент в конец каждого элемента, переданного в качестве аргумента:
    $("<hr/>").appendTo("p") — «линия будет добавлена в конец каждого параграфа»
    $("нашли элемент").append("что туда дописываем?")
    $("что дописываем").appendTo("в какой элемент?")

    prepend(content) — вставляет контент в начало каждого элемента из выборки
    prependTo(element) — вставляет выбранный контент в начало каждого элемента, переданного в качестве аргумента

    replaceWith(content) – заменяет найденные элементы новым: $("p").replaceWith("<hr/>")
    replaceAll(target) – вставляет контент взамен найденному: $("<hr/>").replaceAll("h3")

    $("нашли элемент").replaceWith("на что меняем?")
    $("что вставляем").replaceAll("вместо чего?")

    wrap(element) – оборачивает каждый найденный элемент новым элементом
    wrapAll(element) – оборачивает найденные элементы новым элементом (все в один)
    wrapInner(element) – оборачивает контент каждого найденного элемента (внутри родительского) новым элементом
    unwrap() – удаляет родительский элемент у найденных элементов

    clone(withDataAndEvents) – клонирует выбранные элементы, для дальнейшей вставки копий назад в DOM, позволяет так же копировать и обработчики событий

    detach() – удаляет элемент из DOM, но при этом сохраняет все данные о нём в jQuery; следует использовать, если надо лишь временно удалить элемент
    empty() – удаляет текст и дочерние DOM-элементы
    remove() – насовсем удаляет элемент из DOM
    html() – возвращает HTML заданного элемента
    html(newHtml) – заменяет HTML в заданном элементе
    text() – возвращает текст заданного элемента; если внутри элемента будут другие HTML-теги, то вернётся сборная солянка из текста всех элементов
    text(newText) – заменяет текст внутри выбранных элементов, при попытке вставить таким образом HTML, будет получен текст, где тэги будут приведены к HTML entities

----------------------------------------------------------------------------------------------------------------------------------------------------------------
    offset() – возвращает позицию DOM-элемента относительно document, данные будут получены в виде объекта: «{ top: 10, left: 30 }»
    offset({ top: 10, left: 30 }) – устанавливает расположение DOM-элемента по указанным координатам

    position() – возвращает позицию DOM-элемента относительно родительского элемента

    height() – возвращает высоту элемента за вычетом отступов и границ; если у нас несколько элементов в выборке, то вернётся первый; значение, в отличие от метода «css('height')», возвращается без указания единиц измерения
    height(height) — устанавливает высоту всех элементов в выборке; если значение высоты передано без указания единиц измерения, то это будут пиксели («px»)

    // в качестве памятки, взято из мануала
    $(window).height();   // высота окна
    $(document).height(); // высота HTML документа
    width() и width(width) – ведут себя аналогично методу «.height()», но работают с шириной элемента

    innerHeight() и innerWidth() – возвращают, соответственно, высоту и ширину элемента, включая «padding»
    outerHeight() и outerWidth() – возвращают высоту и ширину элемента, включая «padding» и «border»

    outerHeight(true) и outerWidth(true) – возвращают высоту и ширину элемента, включая «padding», «border» и «margin»

    scrollLeft() – возвращает значение «проскролленности» по горизонтали для первого элемента из выборки
    scrollLeft(value) – устанавливает значение горизонтального скролла для каждого элемента из выборки
    scrollTop() – возвращает значение «проскролленности» по вертикали для первого элемента из выборки
    scrollTop(value) – устанавливает значение вертикального скролла для каждого элемента из выборки

    Вот таким образом мы можем узнать «расстояние» пройденное от начала страницы:
    alert($('.body-inner').scrollTop());

    Или можем «прыгнуть» в самое начало страницы:
    $('.body-inner').scrollTop(0);
    можно плавно:
    $('.body-inner').animate({ scrollTop: '-=200px' });
    $('.body-inner').animate({ scrollTop: '0px' });
    --------------------------------------------------------------------------------------------------------------------

    AJAX

    ПОДГОТОВКА ЗАПРОСА

    благодаря этому объекту мы отправляем запрос и получаем ответ с сервера:
    <script>
        var xhr = new XMLHttpRequest();
    </script>
    свойства объекта:
    readyState - позволяет узнать сосотояние готовности запроса (0,1,2,3,4  - стадии запроса, если все прошло корректно, то получим код "4")
                 он нужен для проверки успешного запроса вместе с статусом ответа сервера
    onreadystatechange - содержитт обработчик события, который булет вызван при изменении значения readyState
    status - Код статуса HTTP возвращенный сервером
    responseText - данные возвращенные сервером в текстовом фромате
    responseXML - данные возвращенные сервером в фромате XML

    методы:
    open() - настраивает запрос
    send() - открывает соединение и отправляет запрос на сервер
    abort() - отмена текущего запроса
    setRequestHeader - устанавливает заголовок запроса
    getResponseHeader - возвращение щначения параметра в виде строки
    getAllResponseHeaders() - возвращение всех заголовков в виде сток
    <script>
        xhr.onreadystatechange = function () {
            if (this.readyState === 4 && this.status === 200){ //если прошли все состояния запроса и ответ сервера с кодом 200 (успешен), тогда уже выполняем что нам нужно
                myFunction(this.responseText);
            }
        }

        function myFunction(data){
            console.log(data)
        }
    </script>

    ОТПРАВКА ЗАПРОСА

    <script>
        xhr.open('GET', 'http://...', true/*3й необязательный параметр - как выполнять запрос, синхронно false или асинхронно true */);
        xhr.send();
    </script>

    для POST запроса, нужно выполнить конфигурацию заголовков запроса

    <script>
        xhr.open('POST', 'http://...', true);

        xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //как обрабатывать запрос

        xhr.send('some params');
    </script>

    пример простейшиего запроса:
    <script>
        (function ($, undefined) {                     //document.ready
            $('button').on('click', myFunction);        //вешаем обработчик на кнопку при клике
        })(jQuery);

        function myFunction(){
            $.post(
                "http://getpost.itgid.info/index2.php", // адрес куда отправить запрос
                {},  // - здесь передаем переменные если нужно таковые отправить (в данном случае будут доступны в суперглобальной переменной $_POST)
                function (data) {       //функция которая будет обрабатывать ответ
                    console.log(data);
                }
            )
        }
    </script>


    Для загрузки html подойдет метод «.load()». Данный метод может принимать следующие параметры:
    url – запрашиваемой страницы
    data – передаваемые данные (необязательный параметр)
    callback – функция, которая будет вызвана при завершении запроса к серверу (необязательный параметр)

    // в элемент с id="content" будет вставлен HTML с указанной страницы
    $("#content").load("../code/html.example.html");

    // в элемент с id="content" будет вставлен HTML с указанной страницы,
    // но не весь, а только выбранный по указанному селектору id="intro"
    $("#content").load("../code/html.example.html #intro");

    // обрабатываем полученные данные
    $("#content").load("../code/html.example.html #intro", function(data) {
    // ничего оригинальней не придумал
    alert("Мы загрузили HTML длиной в " + data.length + " символов");
    });

    // передаём данные на сервер вторым параметром
    // вот только сервер наш их никак не обрабатывает
    // но вы можете увидеть данные в консоли, в отправленных запросах
    $("#content").load("../code/html.example.html #intro", {id: 42});

    ОБРАБОТЧИКИ ОШИБОК

    var D = $.Deferred();

    // подключаем обработчик ошибок через then()
    D.then(null, function() { console.log("fail") });

    // подключаем обработчик ошибок через catch()
    D.catch(function() { console.log("again fail") });

    метод «.always()» – он добавляет обработчики, которые будут выполнены вне зависимости от случившегося
    (в действительности, внутри происходит вызов «.done(arguments)» и «.fail(arguments)»).


какой-то пример по выполнению функция по очереди
    если убрать какой-то «return», то следующая анимация наступит не дождавшись завершения предыдущей
    <script>
        var D = $.Deferred();

        D.then(function() {
            // подождём окончания AJAX-запроса
            return $('article img').slideUp(2000).promise()
        })
            .then(function(){
                // подождём, пока спрячутся картинки
                return $('article p').slideUp(2000).promise()
            })
            .then(function(){
                // подождём, пока спрячутся параграфы
                return $('article').hide(2000).promise()
            })
            .then(function(){
                // всё сделано
            });

        D.resolve();
    </script>

    связка методов «.notify()» и «.progress()»
    <script>
        var D = $.Deferred();

        var money = 100; // наш бюджет

        // съём денежки
        D.progress(function($){
            console.log(money + " - " + $ + " = " + (money-$));
            money -= $;
            if (money < 0) { // деньги закончились
                D.reject();
            }
        });

        // тратим деньги
        setTimeout(function(){ D.notify(40); }, 500);  // покупка 1
        setTimeout(function(){ D.notify(50); }, 1000); // покупка 2
        setTimeout(function(){ D.notify(30); }, 1500); // покупка 3

        D.then(function(){ console.info("All Ok") });
        D.catch(function(){ console.error("Insufficient Funds") });
    </script>
    --------------------------------------------------------------------------------------------------------------
    Callbacks

    Callbacks -  позволяет составлять списки функций обратного вызова, которые будет выполнены по команде «.fire()»
    <script>
        var C = $.Callbacks();

        C.add(function(msg) {
            console.log(msg + " first")
        });

        C.add(function(msg) {
            console.log(msg + " second")
        });

        C.fire("Go");
    </script>

        По умолчанию вы можете прямо из консоли вызывать метод «.fire()» снова и снова, и будете получать один и тот же
        результат раз за разом. А можно задать поведение Callbacks через флаги:
    once — все функции будут вызваны единожды (аналогично как в объекте Deferred).
    memory — сохранять значение с последнего вызова «.fire()», и скармливать его в ново-зарегистрированные функции
        обратного вызова, и лишь потом обрабатывает новое значение (в Deferred именно так).
    unique — список функций обратного вызова фильтруется по уникальности
    stopOnFalse — как только какая-нибудь функция вернёт «false», процесс запуска остановится
    <script>
        var C = $.Callbacks("once");

        C.add(function(msg) {
            console.log(msg + " first")
        });

        C.add(function(msg) {
            console.log(msg + " second")
        });

        C.fire("Go");

        C.fire("Again"); // не даст результата, только Go
    </script>
    Go first
    Go second


    вообще нихуя не понял
    <script>
        var C = $.Callbacks("memory")

        C.add(function (msg) {
            console.log(msg + "first")
        });

        C.fire("Go");

        C.add(function (msg) {
            console.log(msg + "second")
        });

        C.fire("Again");
    </script>
    Go first
    Go second // без флага, этой строчки не было бы
    Again first
    Again second

    ...
    <script>
        var C = $.Callbacks("unique");

        var func = function(msg) {
            console.log(msg + " first")
        };

        C.add(func);
        C.add(func); // эта строка не повлияет на результат

        C.fire("Go"); // только Go first
    </script>
    Go first

    Флаг «stopOnFalse»:
    <script>
        var C = $.Callbacks("stopOnFalse");

        C.add(function(msg) {
            console.log(msg + " first");
            return false; // вот он – роковой false
        });

        C.add(function(msg) {
            console.log(msg + " second");
        });

        C.fire("Go"); // только Go first
    </script>
    Go first
----------------------------------------------------------------
    Работа с формами

    <script>
        $("form").submit(function(){
            // для читаемости кода
            var $form = $(this);
            // вы же понимаете, о чём я тут толкую?
            // это ведь одна из ипостасей AJAX-запроса
            $.post(
                $form.attr("action"), // ссылка куда отправляем данные
                $form.serialize()     // данные формы
            );
            // отключаем действие по умолчанию
            return false;
        });
    </script>

    serialize() - в ответе за «сбор» данных с формы в удобном для передачи данных формате:
    firstname=Ivan&lastname=Ivanov

    Также есть метод «.serializeArray()» – он представляет собранные данные в виде объекта:
    [
        {
            "name": "firstname",
            "value": "Ivan"
            },
            {
            "name": "lastname",
            "value": "Ivanov"
        }
    ]

    val() – получение значения первого элемента формы из выборки
    val(value) – установка значения всем элементам формы из выборки

    focus — фокус на элементе, для работы с данным событием так же есть «shorthand» метод «.focus()»; потребуется, если надо вывести подсказку к элементу формы при наведении
    blur — фокус ушёл с элемента + метод «.blur()»; пригодится при валидации формы по мере заполнения полей
    select — выбор текста в «textarea» и «input[type=text]» + метод «.select()»; если соберётесь разрабатывать свой WYSIWYG, то познакомитесь очень плотно


    Проверка «чекнутость» простым скриптом:
    <script>
        alert(
            $("input[type=checkbox]").prop("checked")
        )
    </script>
    или
    <script>
        alert(
            $("input[type=checkbox]").is(":checked")
        );
    </script>

    добавление выпадающего списка в форму
    <script>
        $("form").append('<select name="some"></select>');
    </script>


    <script>
        //$select = выбран элемент select из формы у которго имя role
        var $select = $("form select[name=role]")
        //добавим новый элемент в выпадающий список
        $select.append("<option>SomeOption</option>");
        // выберем необходимый элемент
        $select.val("SomeOption");
        // или по порядковому номеру, начиная с 0. (в данном случае выберет 2й элемент списка)
        $select.find("option:eq(1)").prop("selected", true);
    </script>

    <script>

    </script>

    <script>

    </script>

    <script>

    </script>

    <script>

    </script>

    <script>

    </script>
    
</head>
<body>

</body>
</html>